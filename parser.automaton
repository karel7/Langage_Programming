State 0:
prog' -> . prog [ # ]
-- On STRUCT shift to state 1
-- On FUN shift to state 14
-- On prog shift to state 46
-- On list(decl) shift to state 47
-- On decl shift to state 49
-- On EOF reduce production list(decl) -> 

State 1:
decl -> STRUCT . IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END [ STRUCT FUN EOF ]
-- On IDENT shift to state 2

State 2:
decl -> STRUCT IDENT . BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END [ STRUCT FUN EOF ]
-- On BEGIN shift to state 3

State 3:
decl -> STRUCT IDENT BEGIN . loption(separated_nonempty_list(COMMA,struct_argument)) END [ STRUCT FUN EOF ]
-- On IDENT shift to state 4
-- On struct_argument shift to state 8
-- On separated_nonempty_list(COMMA,struct_argument) shift to state 11
-- On loption(separated_nonempty_list(COMMA,struct_argument)) shift to state 12
-- On END reduce production loption(separated_nonempty_list(COMMA,struct_argument)) -> 

State 4:
struct_argument -> IDENT . COLON typ [ END COMMA ]
-- On COLON shift to state 5

State 5:
struct_argument -> IDENT COLON . typ [ END COMMA ]
-- On IDENT shift to state 6
-- On typ shift to state 7

State 6:
typ -> IDENT . [ RIGHTPAR END COMMA BEGIN ]
-- On RIGHTPAR reduce production typ -> IDENT 
-- On END reduce production typ -> IDENT 
-- On COMMA reduce production typ -> IDENT 
-- On BEGIN reduce production typ -> IDENT 

State 7:
struct_argument -> IDENT COLON typ . [ END COMMA ]
-- On END reduce production struct_argument -> IDENT COLON typ 
-- On COMMA reduce production struct_argument -> IDENT COLON typ 

State 8:
separated_nonempty_list(COMMA,struct_argument) -> struct_argument . [ END ]
separated_nonempty_list(COMMA,struct_argument) -> struct_argument . COMMA separated_nonempty_list(COMMA,struct_argument) [ END ]
-- On COMMA shift to state 9
-- On END reduce production separated_nonempty_list(COMMA,struct_argument) -> struct_argument 

State 9:
separated_nonempty_list(COMMA,struct_argument) -> struct_argument COMMA . separated_nonempty_list(COMMA,struct_argument) [ END ]
-- On IDENT shift to state 4
-- On struct_argument shift to state 8
-- On separated_nonempty_list(COMMA,struct_argument) shift to state 10

State 10:
separated_nonempty_list(COMMA,struct_argument) -> struct_argument COMMA separated_nonempty_list(COMMA,struct_argument) . [ END ]
-- On END reduce production separated_nonempty_list(COMMA,struct_argument) -> struct_argument COMMA separated_nonempty_list(COMMA,struct_argument) 

State 11:
loption(separated_nonempty_list(COMMA,struct_argument)) -> separated_nonempty_list(COMMA,struct_argument) . [ END ]
-- On END reduce production loption(separated_nonempty_list(COMMA,struct_argument)) -> separated_nonempty_list(COMMA,struct_argument) 

State 12:
decl -> STRUCT IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) . END [ STRUCT FUN EOF ]
-- On END shift to state 13

State 13:
decl -> STRUCT IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END . [ STRUCT FUN EOF ]
-- On STRUCT reduce production decl -> STRUCT IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END 
-- On FUN reduce production decl -> STRUCT IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END 
-- On EOF reduce production decl -> STRUCT IDENT BEGIN loption(separated_nonempty_list(COMMA,struct_argument)) END 

State 14:
decl -> FUN . IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block [ STRUCT FUN EOF ]
decl -> FUN . IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block [ STRUCT FUN EOF ]
-- On IDENT shift to state 15

State 15:
decl -> FUN IDENT . LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block [ STRUCT FUN EOF ]
decl -> FUN IDENT . LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block [ STRUCT FUN EOF ]
-- On LEFTPAR shift to state 16

State 16:
decl -> FUN IDENT LEFTPAR . loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block [ STRUCT FUN EOF ]
decl -> FUN IDENT LEFTPAR . loption(separated_nonempty_list(COMMA,argument)) block [ STRUCT FUN EOF ]
-- On MUT shift to state 17
-- On separated_nonempty_list(COMMA,argument) shift to state 18
-- On option(MUT) shift to state 19
-- On loption(separated_nonempty_list(COMMA,argument)) shift to state 23
-- On argument shift to state 43
-- On RIGHTPAR reduce production loption(separated_nonempty_list(COMMA,argument)) -> 
-- On IDENT reduce production option(MUT) -> 
-- On BEGIN reduce production loption(separated_nonempty_list(COMMA,argument)) -> 

State 17:
option(MUT) -> MUT . [ IDENT ]
-- On IDENT reduce production option(MUT) -> MUT 

State 18:
loption(separated_nonempty_list(COMMA,argument)) -> separated_nonempty_list(COMMA,argument) . [ RIGHTPAR BEGIN ]
-- On RIGHTPAR reduce production loption(separated_nonempty_list(COMMA,argument)) -> separated_nonempty_list(COMMA,argument) 
-- On BEGIN reduce production loption(separated_nonempty_list(COMMA,argument)) -> separated_nonempty_list(COMMA,argument) 

State 19:
argument -> option(MUT) . IDENT COLON typ [ RIGHTPAR COMMA BEGIN ]
-- On IDENT shift to state 20

State 20:
argument -> option(MUT) IDENT . COLON typ [ RIGHTPAR COMMA BEGIN ]
-- On COLON shift to state 21

State 21:
argument -> option(MUT) IDENT COLON . typ [ RIGHTPAR COMMA BEGIN ]
-- On IDENT shift to state 6
-- On typ shift to state 22

State 22:
argument -> option(MUT) IDENT COLON typ . [ RIGHTPAR COMMA BEGIN ]
-- On RIGHTPAR reduce production argument -> option(MUT) IDENT COLON typ 
-- On COMMA reduce production argument -> option(MUT) IDENT COLON typ 
-- On BEGIN reduce production argument -> option(MUT) IDENT COLON typ 

State 23:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) . RIGHTPAR IMPLY typ block [ STRUCT FUN EOF ]
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) . block [ STRUCT FUN EOF ]
-- On RIGHTPAR shift to state 24
-- On BEGIN shift to state 27
-- On block shift to state 42

State 24:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR . IMPLY typ block [ STRUCT FUN EOF ]
-- On IMPLY shift to state 25

State 25:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY . typ block [ STRUCT FUN EOF ]
-- On IDENT shift to state 6
-- On typ shift to state 26

State 26:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ . block [ STRUCT FUN EOF ]
-- On BEGIN shift to state 27
-- On block shift to state 41

State 27:
block -> BEGIN . list(instruction) expr END [ STRUCT FUN EOF ]
block -> BEGIN . list(instruction) END [ STRUCT FUN EOF ]
-- On PRINT shift to state 28
-- On list(instruction) shift to state 33
-- On instruction shift to state 37
-- On expr shift to state 39
-- On PRINT reduce production list(instruction) -> 
-- On END reduce production list(instruction) -> 
** Conflict on PRINT

State 28:
expr -> PRINT . EXCL LEFTPAR CHAIN RIGHTPAR [ SEMICOLON END ]
-- On EXCL shift to state 29

State 29:
expr -> PRINT EXCL . LEFTPAR CHAIN RIGHTPAR [ SEMICOLON END ]
-- On LEFTPAR shift to state 30

State 30:
expr -> PRINT EXCL LEFTPAR . CHAIN RIGHTPAR [ SEMICOLON END ]
-- On CHAIN shift to state 31

State 31:
expr -> PRINT EXCL LEFTPAR CHAIN . RIGHTPAR [ SEMICOLON END ]
-- On RIGHTPAR shift to state 32

State 32:
expr -> PRINT EXCL LEFTPAR CHAIN RIGHTPAR . [ SEMICOLON END ]
-- On SEMICOLON reduce production expr -> PRINT EXCL LEFTPAR CHAIN RIGHTPAR 
-- On END reduce production expr -> PRINT EXCL LEFTPAR CHAIN RIGHTPAR 

State 33:
block -> BEGIN list(instruction) . expr END [ STRUCT FUN EOF ]
block -> BEGIN list(instruction) . END [ STRUCT FUN EOF ]
-- On PRINT shift to state 28
-- On END shift to state 34
-- On expr shift to state 35

State 34:
block -> BEGIN list(instruction) END . [ STRUCT FUN EOF ]
-- On STRUCT reduce production block -> BEGIN list(instruction) END 
-- On FUN reduce production block -> BEGIN list(instruction) END 
-- On EOF reduce production block -> BEGIN list(instruction) END 

State 35:
block -> BEGIN list(instruction) expr . END [ STRUCT FUN EOF ]
-- On END shift to state 36

State 36:
block -> BEGIN list(instruction) expr END . [ STRUCT FUN EOF ]
-- On STRUCT reduce production block -> BEGIN list(instruction) expr END 
-- On FUN reduce production block -> BEGIN list(instruction) expr END 
-- On EOF reduce production block -> BEGIN list(instruction) expr END 

State 37:
list(instruction) -> instruction . list(instruction) [ PRINT END ]
-- On PRINT shift to state 28
-- On list(instruction) shift to state 38
-- On instruction shift to state 37
-- On expr shift to state 39
-- On PRINT reduce production list(instruction) -> 
-- On END reduce production list(instruction) -> 
** Conflict on PRINT

State 38:
list(instruction) -> instruction list(instruction) . [ PRINT END ]
-- On PRINT reduce production list(instruction) -> instruction list(instruction) 
-- On END reduce production list(instruction) -> instruction list(instruction) 

State 39:
instruction -> expr . SEMICOLON [ PRINT END ]
-- On SEMICOLON shift to state 40

State 40:
instruction -> expr SEMICOLON . [ PRINT END ]
-- On PRINT reduce production instruction -> expr SEMICOLON 
-- On END reduce production instruction -> expr SEMICOLON 

State 41:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block . [ STRUCT FUN EOF ]
-- On STRUCT reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block 
-- On FUN reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block 
-- On EOF reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) RIGHTPAR IMPLY typ block 

State 42:
decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block . [ STRUCT FUN EOF ]
-- On STRUCT reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block 
-- On FUN reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block 
-- On EOF reduce production decl -> FUN IDENT LEFTPAR loption(separated_nonempty_list(COMMA,argument)) block 

State 43:
separated_nonempty_list(COMMA,argument) -> argument . [ RIGHTPAR BEGIN ]
separated_nonempty_list(COMMA,argument) -> argument . COMMA separated_nonempty_list(COMMA,argument) [ RIGHTPAR BEGIN ]
-- On COMMA shift to state 44
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,argument) -> argument 
-- On BEGIN reduce production separated_nonempty_list(COMMA,argument) -> argument 

State 44:
separated_nonempty_list(COMMA,argument) -> argument COMMA . separated_nonempty_list(COMMA,argument) [ RIGHTPAR BEGIN ]
-- On MUT shift to state 17
-- On separated_nonempty_list(COMMA,argument) shift to state 45
-- On option(MUT) shift to state 19
-- On argument shift to state 43
-- On IDENT reduce production option(MUT) -> 

State 45:
separated_nonempty_list(COMMA,argument) -> argument COMMA separated_nonempty_list(COMMA,argument) . [ RIGHTPAR BEGIN ]
-- On RIGHTPAR reduce production separated_nonempty_list(COMMA,argument) -> argument COMMA separated_nonempty_list(COMMA,argument) 
-- On BEGIN reduce production separated_nonempty_list(COMMA,argument) -> argument COMMA separated_nonempty_list(COMMA,argument) 

State 46:
prog' -> prog . [ # ]
-- On # accept prog

State 47:
prog -> list(decl) . EOF [ # ]
-- On EOF shift to state 48

State 48:
prog -> list(decl) EOF . [ # ]
-- On # reduce production prog -> list(decl) EOF 

State 49:
list(decl) -> decl . list(decl) [ EOF ]
-- On STRUCT shift to state 1
-- On FUN shift to state 14
-- On list(decl) shift to state 50
-- On decl shift to state 49
-- On EOF reduce production list(decl) -> 

State 50:
list(decl) -> decl list(decl) . [ EOF ]
-- On EOF reduce production list(decl) -> decl list(decl) 

